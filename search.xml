<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二叉排序树及平衡二叉树的实现</title>
      <link href="/2025/02/14/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E5%8F%8A%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2025/02/14/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E5%8F%8A%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉排序树及平衡二叉树的实现"><a href="#二叉排序树及平衡二叉树的实现" class="headerlink" title="二叉排序树及平衡二叉树的实现"></a>二叉排序树及平衡二叉树的实现</h1><h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title=" 二叉排序树"></a><font color = "#ff0000" size = "4px"> 二叉排序树</font></h2><font color = "#2D8686" size = "4px">二叉排序树，又称为二叉查找树。它或者是一颗空树，或者具有下列性质   的二叉树。</font><blockquote><p>•若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</p></blockquote><blockquote><p>•若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</p></blockquote><blockquote><p>•它的左、右子树也分别为二叉排序树。</p></blockquote><blockquote><p>构造一颗二叉排序树的目的，其实并不是为了排序，而是为了提高查找和&gt;插入删除关键字的速度。不管怎么说，在一个有序数据集上的查找，速度总是要快于无序数据集的，而二叉排序树这种非线性的结构，也有利于插入和删除的实现。<br><strong>插入和查找比较简单，在这里我就不详细说明了。</strong></p></blockquote><h3 id="1、二叉排序树的插入"><a href="#1、二叉排序树的插入" class="headerlink" title="1、二叉排序树的插入"></a>1、二叉排序树的插入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BinSortInsert</span><span class="params">(BTree *root,<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(*root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">*root = (BTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BtNode));</span><br><span class="line">(*root)-&gt;data = num;</span><br><span class="line">(*root)-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">(*root)-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>((*root)-&gt;data == num)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;要插入的结点已存在！&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>((*root)-&gt;data &gt; num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">BinSortInsert</span>(&amp;(*root)-&gt;left,num); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">BinSortInsert</span>(&amp;(*root)-&gt;right,num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、二叉排序树的查找"><a href="#2、二叉排序树的查找" class="headerlink" title="2、二叉排序树的查找"></a>2、二叉排序树的查找</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BtNode* <span class="title">BinSortSearch</span><span class="params">(BTree root,<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BtNode* p = root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//若为空则没有该节点 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;data == num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;data &gt; num)</span><br><span class="line">&#123;</span><br><span class="line">p = <span class="built_in">BinSortSearch</span>(p-&gt;left,num);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">p = <span class="built_in">BinSortSearch</span>(p-&gt;right,num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面着重讲下删除操作：<br>   首先，找到要删除的结点p，可以遍历，也可以调用上面已经写好的查找函数。<br>   然后，p的情况分为三种：<br>（1）、p为叶子节点；直接删除p。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure><p> 5901<br>（2）、p的左右子树之一为空；</p><p>左孩子为空,用q保存p结点，让p指向它的右孩子，再释放q；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BtNode *q;</span><br><span class="line">q = p;</span><br><span class="line">p = p-&gt;right;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure><p>6582</p><p>右孩子为空,用q保存p结点，让p指向它的左孩子，再释放q；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BtNode *q;</span><br><span class="line">q = p;</span><br><span class="line">p = p-&gt;left;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure><p>7244<br>（3）、p的左右子树都不为空；<br>左右孩子都不为空,则先找到p的直接前驱结点s,并记录s的父节点q;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BtNode *q,*s;</span><br><span class="line">q-&gt;right = s-&gt;left;</span><br><span class="line">p-&gt;data = s-&gt;data;</span><br><span class="line"><span class="built_in">free</span>(s);</span><br></pre></td></tr></table></figure><p>7949</p><h3 id="3、二叉排序树的删除"><a href="#3、二叉排序树的删除" class="headerlink" title="3、二叉排序树的删除"></a>3、二叉排序树的删除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">void DeleteNode(BtNode **p)</span><br><span class="line">&#123;</span><br><span class="line">BtNode *q,*s;</span><br><span class="line">    if((*p)-&gt;left == NULL &amp;&amp; (*p)-&gt;right == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">    free(*p);</span><br><span class="line">    &#125;</span><br><span class="line">    else if((*p) == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">    q = *p;</span><br><span class="line">    *p = (*p)-&gt;right;</span><br><span class="line">    free(q);</span><br><span class="line">    &#125;</span><br><span class="line">    else if((*p) == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">    q = *p;</span><br><span class="line">    *p = (*p)-&gt;left;</span><br><span class="line">    free(q);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">    q = *p;</span><br><span class="line">    s = q-&gt;left;</span><br><span class="line">    while(s-&gt;right)</span><br><span class="line">    &#123;</span><br><span class="line">    q = s;</span><br><span class="line">    s = s-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;right = s-&gt;left;</span><br><span class="line">    (*p)-&gt;data = s-&gt;data;</span><br><span class="line">    free(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void BinSortDelete(BTree *root,int num)</span><br><span class="line">&#123;</span><br><span class="line">BtNode * p = BinSortSearch(*root,num);</span><br><span class="line">if(p == NULL)</span><br><span class="line">&#123;</span><br><span class="line">return;</span><br><span class="line">&#125; </span><br><span class="line">DeleteNode(&amp;p);</span><br><span class="line">/*</span><br><span class="line">BtNode *p = *root;</span><br><span class="line"></span><br><span class="line">if(p == NULL)</span><br><span class="line">&#123;</span><br><span class="line">return;</span><br><span class="line">&#125; </span><br><span class="line">if(p-&gt;data == num)</span><br><span class="line">&#123;</span><br><span class="line">DeleteNode(&amp;p);</span><br><span class="line">&#125;</span><br><span class="line">else if (p-&gt;data &gt; num)</span><br><span class="line">&#123;</span><br><span class="line">BinSortDelete(&amp;(p-&gt;left),num);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">BinSortDelete(&amp;(p-&gt;right),num);</span><br><span class="line">&#125;*/</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、二叉排序树整体实现"><a href="#4、二叉排序树整体实现" class="headerlink" title="4、二叉排序树整体实现"></a>4、二叉排序树整体实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BTree BT = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">cin&gt;&gt;num;</span><br><span class="line"><span class="keyword">while</span>(num != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">BinSortInsert</span>(&amp;BT,num))</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BinSortDelete</span>(&amp;BT,<span class="number">32</span>);</span><br><span class="line"><span class="built_in">PrintBTree</span>(BT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color = "#3401f6" size = "4px">**总结**：二叉排序树的时间复杂度为O(logn),n为节点个数，log为树的深度，最坏的情况logn = n 即时间复杂度为O(n)优点在于采用链式存储（插入删除较方便）的同时，还能保证查找的时间复杂度不会太高。但是它的缺点在于，随着插入的进行，树的形状可能会趋于不平衡，如下图所示。所以才有了AV树，通过插入后的旋转，改善了二叉排序树插入、删除导致的不平衡。</font>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 平衡二叉树 </tag>
            
            <tag> 二叉排序树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交换类排序——冒泡排序和快速排序</title>
      <link href="/2025/02/14/%E4%BA%A4%E6%8D%A2%E7%B1%BB%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2025/02/14/%E4%BA%A4%E6%8D%A2%E7%B1%BB%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="交换类排序"><a href="#交换类排序" class="headerlink" title="交换类排序"></a>交换类排序</h1><hr><h2 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len)</span><span class="comment">//冒泡排序 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i&lt;= len; i++)  <span class="comment">//趟数秩序冒泡len-1趟就可全部排完 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j&lt;= len-i; j++)   <span class="comment">//每排一趟就有一个数放到正确的位置不需在参与排序 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j] &gt; a[j<span class="number">+1</span>])</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">0</span>] = a[j];</span><br><span class="line">a[j] = a[j<span class="number">+1</span>];</span><br><span class="line">a[j<span class="number">+1</span>] = a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!flag)   <span class="comment">//若经过一趟排序，没有元素交换位置则不必在进行排序 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color = "#0x0066ff" size = "4px">算法分析：</font><font color = "#0x22dd22" size = "4px">　　时间：O(n2)  　　通常认为冒泡是比较差的，可以加些改进，比如在一趟中无数据的交换，则结束等措施。**因此此处我采用了标志法改进了冒泡算法，假如在一趟交换中没有任何元素位置发生交换，则排序结束**。</font><h2 id="二、快速排序"><a href="#二、快速排序" class="headerlink" title="二、快速排序"></a>二、快速排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> left, <span class="type">int</span> right)</span><span class="comment">//快速排序 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(right &lt;= left)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> i = left;</span><br><span class="line"><span class="type">int</span> j = right;</span><br><span class="line">a[<span class="number">0</span>] = a[left];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">while</span>(a[j] &gt;= a[<span class="number">0</span>] &amp;&amp; i&lt;j)</span><br><span class="line">     <span class="comment">/*一定要j先走，因为我们在j=i时将表的第一个数与地i个数交换，故要先找到比隔板小的而不是先找到比隔板（支点）大的； */</span></span><br><span class="line">    &#123;</span><br><span class="line">    j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a[i] &lt;= a[<span class="number">0</span>] &amp;&amp; i&lt;j) </span><br><span class="line">    &#123;</span><br><span class="line">    i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="type">int</span> tmp = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">a[left] = a[i];</span><br><span class="line">a[i] = a[<span class="number">0</span>];</span><br><span class="line">&#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i<span class="number">-1</span> &gt; left)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">QuickSort</span>(a,left,i<span class="number">-1</span>);      <span class="comment">//若隔板左边小于等于一个元素则不必在排 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i<span class="number">+1</span> &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">QuickSort</span>(a,i<span class="number">+1</span>,right);    <span class="comment">//若隔板左边小于等于一个元素则不必在排 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><font color = "#0x0066ff" size = "4px">算法分析:</font><font color = "#0x22dd22" size = "4px">核心思想：取数组的首元素作为支点（有的书上从中间取，效率要高，核心思想都是一样的，在这里我就为了方便起见取首元素作为支点。），然后在其余元素组成的数组中设置两个指针ｌ，ｒ；分别位于数组最左边和最右边。让右边指针先走(很重要，原因看代码中的注释)，找到一个小于支点的元素。再让左边走，找到一个大于支点的元素。判断ｌ，ｒ是否重合。若重合则交换该位置与数组首位置的值；若不重合，交换ｌ，ｒ位置的值。并且以该位置为分界点，分别递归处理支点左右两侧的数组，最后完成整个排序</font><img src="/2025/02/14/%E4%BA%A4%E6%8D%A2%E7%B1%BB%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/quick_sort.png" class="" alt="快速排序演示"><blockquote><p>A)时间复杂度<br><font color = "#0x22dd22" size = "4px"><br> 最好情况（每次支点总是在中间）T(n)&#x3D;O(nlog2n)<br>  平均 T(n)&#x3D;O(nlog2n)<br> 最坏情况（数据已是递增或递减）T(n)&#x3D;O(n²)<br>  </font></p></blockquote><blockquote><p>B)空间复杂度：需栈空间以实现递归<br><font color = "#0x22dd22" size = "4px"><br>最坏情况：S(n)&#x3D;O(n)<br>一般情况：S(n)&#x3D;O(log2n)<br> </font></p></blockquote><h2 id="三、整体实现"><a href="#三、整体实现" class="headerlink" title="三、整体实现"></a>三、整体实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len)</span><span class="comment">//冒泡排序 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i&lt;= len; i++)  <span class="comment">//趟数秩序冒泡len-1趟就可全部排完 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j&lt;= len-i; j++)   <span class="comment">//每排一趟就有一个数放到正确的位置不需在参与排序 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j] &gt; a[j<span class="number">+1</span>])</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">0</span>] = a[j];</span><br><span class="line">a[j] = a[j<span class="number">+1</span>];</span><br><span class="line">a[j<span class="number">+1</span>] = a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!flag)   <span class="comment">//若经过一趟排序，没有元素交换位置则不必在进行排序 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> left, <span class="type">int</span> right)</span><span class="comment">//快速排序 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(right &lt;= left)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> i = left;</span><br><span class="line"><span class="type">int</span> j = right;</span><br><span class="line">a[<span class="number">0</span>] = a[left];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">while</span>(a[j] &gt;= a[<span class="number">0</span>] &amp;&amp; i&lt;j) <span class="comment">//一定要j先走，因为我们在j=i时将表的第一个数与地i个数交换，故要先找到比隔板小的而不是先找到比隔板（支点）大的； </span></span><br><span class="line">    &#123;</span><br><span class="line">    j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a[i] &lt;= a[<span class="number">0</span>] &amp;&amp; i&lt;j) </span><br><span class="line">    &#123;</span><br><span class="line">    i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="type">int</span> tmp = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">a[left] = a[i];</span><br><span class="line">a[i] = a[<span class="number">0</span>];</span><br><span class="line">&#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i<span class="number">-1</span> &gt; left)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">QuickSort</span>(a,left,i<span class="number">-1</span>);      <span class="comment">//若隔板左边元素个数小于等于一则不必在排 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i<span class="number">+1</span> &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">QuickSort</span>(a,i<span class="number">+1</span>,right);    <span class="comment">////若隔板右边元素个数小于等于一则不必在排 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintArry</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> len)</span> <span class="comment">//打印数组0号位置设为监视哨 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i&lt;=len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">0</span>,<span class="number">17</span>,<span class="number">21</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">58</span>,<span class="number">45</span>,<span class="number">96</span>,<span class="number">83</span>,<span class="number">69</span>&#125;;</span><br><span class="line"><span class="comment">//BubbleSort(a,9);</span></span><br><span class="line"><span class="built_in">PrintArry</span>(a,<span class="number">9</span>);</span><br><span class="line"><span class="built_in">QuickSort</span>(a,<span class="number">1</span>,<span class="number">9</span>);</span><br><span class="line"><span class="built_in">PrintArry</span>(a,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>上面介绍的<strong>冒泡排序</strong>和<strong>快速排序</strong>就是内部排序家族中交换类排序的两种典型算法。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序</title>
      <link href="/2025/02/14/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>/2025/02/14/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><hr><h2 id="一、直接插入排序"><a href="#一、直接插入排序" class="headerlink" title="一、直接插入排序"></a>一、直接插入排序</h2><p><font color = "#7722ff" size = "4px">算法分析：     从空间角度来看，只需要一个辅助空间r[0]。     从时间角度来看，主要时间耗费在关键字比较和移动元素上。       直接插入排序的时间复杂度为O(n^2),空间复杂度为O(1)。       直接插入排序是稳定的。       **直接插入排序在基本有序时效率较高，并且在序列规模不是很大时效率也很高。**  </font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> len)</span>    <span class="comment">//直接插入排序 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="keyword">for</span>(j = i<span class="number">-1</span>; j &gt; <span class="number">0</span> &amp;&amp; a[j] &gt; a[<span class="number">0</span>]; j--)</span><br><span class="line">&#123;</span><br><span class="line">a[j<span class="number">+1</span>] = a[j];</span><br><span class="line">&#125;</span><br><span class="line">a[j<span class="number">+1</span>] = a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、二分插入排序"><a href="#二、二分插入排序" class="headerlink" title="二、二分插入排序"></a>二、二分插入排序</h2><p><font color = "#7722ff" size = "4px">算法分析：   采用折半插入排序法，可减少关键字的比较次数。每插入一个元素，需要比较的次数最大为折半判定树的深度。**虽然折半插入排序法与直接插入排序法相比较，改善了算法中比较次数的数量级为O(nlog2n),但其并未改变移动元素的时间耗费，所以折半插入排序总的时间复杂度仍然是O(n^2)。**  </font></p><div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinInsertSort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> len)</span> <span class="comment">//二分插入排序 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> low = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> high = i<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    a[<span class="number">0</span>] = a[i];</span><br><span class="line">        <span class="keyword">while</span>(high &gt;= low)</span><br><span class="line">        &#123;</span><br><span class="line">        mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>] &lt;= a[mid]) </span><br><span class="line">        &#123;</span><br><span class="line">        high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//把等于划到这一类可以在有多个相同值时减少相同值移动的次数；</span></span><br><span class="line">        &#123;</span><br><span class="line">        low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= low; j--)</span><br><span class="line">&#123;</span><br><span class="line">a[j<span class="number">+1</span>] =  a[j];</span><br><span class="line">tmp++;</span><br><span class="line">&#125; </span><br><span class="line">cout&lt;&lt;endl&lt;&lt;i&lt;&lt;<span class="string">&quot;移动%d次：&quot;</span>&lt;&lt;tmp&lt;&lt;endl; </span><br><span class="line">a[low] = a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>上述代码中的逻辑设计的实际区别如下：<p>（1）把等于划到下面</p><img src="/2025/02/14/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/insert_sort_1.png" class="" alt="把等于划到下面"><p>（2）把等于划到上面</p><img src="/2025/02/14/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/insert_sort_2.png" class="" alt="把等于划到上面"><p>可见，把等于号放在下面的分支，相当于遇到相等元素时、不再进行比较能够提高效率。</p><h2 id="三、shell排序"><a href="#三、shell排序" class="headerlink" title="三、shell排序"></a>三、shell排序</h2><p><font color = "#7722ff" size = "4px">算法分析：shell排序是对直接插入排序的一种改进（从后续的代码中可以看出），延续了直接插入排序的优点，核心思想是：>待排序列有n个元素，先取一个小于n的整数h1作为第一个增量，把待排序列以间隔h1分成若干子序列，子序列内使用插入排序；>然后取第二个增量h2(< h1)，重复上述的划分和排序，直至所取的增量hl = 1 (h1 > h2 > ... > hl)。对于增量步长的选取有争议（增量的选取会影响时间复杂度），在此我就简单地以每次将初始增量折半为步长。         **Shell排序是一种不稳定的排序算法**，其时间复杂度受增量序列的影响明显大于其他因素，最坏的情况是o(n^2)，好的情况在o(n^1.3)，与增量序列选择有关。  </font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len , <span class="type">int</span> d[], <span class="type">int</span> dlen)</span><span class="comment">//shell排序非递归实现 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>,n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;dlen; ++i)     <span class="comment">//共有dlen种偏移因子 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(n = <span class="number">1</span>; n &lt; d[i]<span class="number">+1</span>; n++)   <span class="comment">//共有d[i]组 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j = n+d[i]; j&lt;=len; j +=d[i])  <span class="comment">//一组插入 </span></span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">0</span>] = a[j];</span><br><span class="line"><span class="type">int</span> k = j-d[i];</span><br><span class="line"><span class="keyword">while</span>(k&gt;<span class="number">0</span> &amp;&amp;  a[k] &gt; a[<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line">a[k+d[i]] = a[k];</span><br><span class="line">k = k-d[i]; </span><br><span class="line">&#125;</span><br><span class="line">a[k+d[i]] = a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><table><thead><tr><th align="left">插入排序</th><th align="left">时间复杂度</th><th align="left">稳定性</th></tr></thead><tbody><tr><td align="left">直接插入排序</td><td align="left">O(n^2)</td><td align="left">稳定</td></tr><tr><td align="left">二分插入排序</td><td align="left">比较O(nlog2n)、移动O(n^2)</td><td align="left">稳定</td></tr><tr><td align="left">shell排序</td><td align="left">O(n^1.5)</td><td align="left">不稳定</td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择类排序</title>
      <link href="/2025/02/14/%E9%80%89%E6%8B%A9%E7%B1%BB%E6%8E%92%E5%BA%8F/"/>
      <url>/2025/02/14/%E9%80%89%E6%8B%A9%E7%B1%BB%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="选择类排序"><a href="#选择类排序" class="headerlink" title="选择类排序"></a>选择类排序</h1><hr><h2 id="一、简单选择排序"><a href="#一、简单选择排序" class="headerlink" title="一、简单选择排序"></a>一、简单选择排序</h2><p>简单选择排序的思路很简单：进行<em><strong>len-1</strong></em>趟选择，剩下一个元素就不用选择了，每一趟将选取的最小的元素放至该趟的起始位置i,那么从<strong>i开始到len为止的元素向后移动一位</strong>。然后再将这个最小值放在该处。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len)</span>   <span class="comment">//简单选择排序 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>,pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i&lt; len; ++i)<span class="comment">//选择的躺数；最后剩下的一个元素已经是最大的了不用再排一趟。 </span></span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">0</span>] = a[i]; <span class="comment">//记录剩下的元素中最小的元素 </span></span><br><span class="line">pos = i;<span class="comment">//记录最小元素的下标 </span></span><br><span class="line"><span class="keyword">for</span>(j = i; j &lt;= len; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j] &lt; a[<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">0</span>] = a[j];</span><br><span class="line">pos = j;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">a[pos] = a[i];</span><br><span class="line">a[i] = a[<span class="number">0</span>]; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、简单选择排序的改进"><a href="#二、简单选择排序的改进" class="headerlink" title="二、简单选择排序的改进"></a>二、简单选择排序的改进</h2><p>从上面可以看出，以上算法的时间复杂度为O(n^2),在这个基础上我们稍作改进：每趟选择最大和最小的两个元素，分别将第i个位置和找到的min交换，第len-i+1与第max个位置交换。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> i,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a[<span class="number">0</span>] = a[i];</span><br><span class="line">a[i] = a[j];</span><br><span class="line">a[j] = a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSortAdvance</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> min =<span class="number">0</span>,max = <span class="number">0</span>;<span class="comment">//记录最小元素和最大元素的下标。</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i&lt;= len/<span class="number">2</span>; i++)     <span class="comment">//最后剩下一个元素或者不剩，都是在中间不用变位置，故一共需要len/趟。 </span></span><br><span class="line">&#123;</span><br><span class="line">min = i;</span><br><span class="line">max = i;</span><br><span class="line"><span class="keyword">for</span>(j = i; j&lt;= len<span class="number">+1</span>-i; j++)   <span class="comment">//注意边界len+1-i； </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j] &gt; a[max])</span><br><span class="line">&#123;</span><br><span class="line">max = j;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span>(a[j] &lt; a[min])</span><br><span class="line">&#123;</span><br><span class="line">min = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">swap</span>(a,i,min);</span><br><span class="line">    <span class="built_in">swap</span>(a,len-i<span class="number">+1</span>,max); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="三、堆排序"><a href="#三、堆排序" class="headerlink" title="三、堆排序"></a>三、堆排序</h2><p>首先：由于堆是一棵完全二叉树，因此初次建立堆将99 , 58 , 230 , 100 , 75 , 69 , 200 , 180 , 66 , 18 , 135的值按下标从1开始一次存储进一个数组a[]；<br>然后：从n&#x2F;2开始到1为止，依次做大根堆调整：选择左右结点中较大的值与该节点交换；然后从刚刚交换的子树结点开始，往下递归这个过程（可用循环实现），直止i大于n一次调整完毕。<br>全部调整完毕后如下所示：</p><img src="/2025/02/14/%E9%80%89%E6%8B%A9%E7%B1%BB%E6%8E%92%E5%BA%8F/heap_sort.png" class="" alt="堆排序"><p>  这样堆化树就建立好了（这里我们建立的是大根堆）；<br><strong>插入操作</strong>：每次插入最后一个位置，然后开始调整，调整的方法为：从该节点的父节点开始向上，递归地调整堆。<br><strong>删除操作</strong>：每次删除根节点，然后将最后一个节点替换根节点，在进行一次由上而下的堆调整。</p><p>排序时，我们每次取堆顶的元素（最大），然后删除堆顶元素。堆化数组的下一个位置可用来存储刚刚删除的结点的值；这样就从后往前，调整了的整个数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> i,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a[<span class="number">0</span>] = a[i];</span><br><span class="line">a[i] = a[j];</span><br><span class="line">a[j] = a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdjustHeap</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n, <span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pos*<span class="number">2</span> &gt;  n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pos*<span class="number">2</span> <span class="number">+1</span> &gt; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[pos*<span class="number">2</span>] &gt; a[pos])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(a,pos,<span class="number">2</span>*pos);</span><br><span class="line"><span class="built_in">AdjustHeap</span>(a,n,pos*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[pos*<span class="number">2</span>] &gt;= a[pos*<span class="number">2</span> <span class="number">+1</span>])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a[pos*<span class="number">2</span>] &gt; a[pos])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(a,pos,<span class="number">2</span>*pos);</span><br><span class="line"><span class="built_in">AdjustHeap</span>(a,n,pos*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a[pos*<span class="number">2</span> + <span class="number">1</span>] &gt; a[pos])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(a,pos,<span class="number">2</span>*pos + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">AdjustHeap</span>(a,n,pos*<span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//删除根节点、并调整堆 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteRoot</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = a[<span class="number">1</span>];</span><br><span class="line">a[<span class="number">1</span>] = a[len];</span><br><span class="line"><span class="built_in">AdjustHeap</span>(a,len<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">a[len] = tmp;</span><br><span class="line"><span class="built_in">PrintArry</span>(a,<span class="number">9</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//初次调整成大根堆 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = len/<span class="number">2</span>; i &gt;<span class="number">0</span>; --i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">AdjustHeap</span>(a,len,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//依次删除根节点 </span></span><br><span class="line"><span class="keyword">while</span>(len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DeleteRoot</span>(a,len);</span><br><span class="line">len--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、整体代码实现"><a href="#四、整体代码实现" class="headerlink" title="四、整体代码实现"></a>四、整体代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len)</span>   <span class="comment">//简单选择排序 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>,pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i&lt; len; ++i)<span class="comment">//选择的躺数；最后剩下的一个元素已经是最大的了不用再排一趟。 </span></span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">0</span>] = a[i]; <span class="comment">//记录剩下的元素中最小的元素 </span></span><br><span class="line">pos = i;<span class="comment">//记录最小元素的下标 </span></span><br><span class="line"><span class="keyword">for</span>(j = i; j &lt;= len; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j] &lt; a[<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">0</span>] = a[j];</span><br><span class="line">pos = j;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">a[pos] = a[i];</span><br><span class="line">a[i] = a[<span class="number">0</span>]; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintArry</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> len)</span>  <span class="comment">//打印函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> i,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a[<span class="number">0</span>] = a[i];</span><br><span class="line">a[i] = a[j];</span><br><span class="line">a[j] = a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSortAdvance</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> min =<span class="number">0</span>,max = <span class="number">0</span>;<span class="comment">//记录最小元素和最大元素的下标。</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i&lt;= len/<span class="number">2</span>; i++)     <span class="comment">//最后剩下一个元素或者不剩，都是在中间不用变位置，故一共需要len/趟。 </span></span><br><span class="line">&#123;</span><br><span class="line">min = i;</span><br><span class="line">max = i;</span><br><span class="line"><span class="keyword">for</span>(j = i; j&lt;= len<span class="number">+1</span>-i; j++)   <span class="comment">//注意边界len+1-i； </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j] &gt; a[max])</span><br><span class="line">&#123;</span><br><span class="line">max = j;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span>(a[j] &lt; a[min])</span><br><span class="line">&#123;</span><br><span class="line">min = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">swap</span>(a,i,min);</span><br><span class="line">    <span class="built_in">swap</span>(a,len-i<span class="number">+1</span>,max); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdjustHeap</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n, <span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pos*<span class="number">2</span> &gt;  n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pos*<span class="number">2</span> <span class="number">+1</span> &gt; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[pos*<span class="number">2</span>] &gt; a[pos])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(a,pos,<span class="number">2</span>*pos);</span><br><span class="line"><span class="built_in">AdjustHeap</span>(a,n,pos*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[pos*<span class="number">2</span>] &gt;= a[pos*<span class="number">2</span> <span class="number">+1</span>])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a[pos*<span class="number">2</span>] &gt; a[pos])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(a,pos,<span class="number">2</span>*pos);</span><br><span class="line"><span class="built_in">AdjustHeap</span>(a,n,pos*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a[pos*<span class="number">2</span> + <span class="number">1</span>] &gt; a[pos])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(a,pos,<span class="number">2</span>*pos + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">AdjustHeap</span>(a,n,pos*<span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//删除根节点、并调整堆 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteRoot</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = a[<span class="number">1</span>];</span><br><span class="line">a[<span class="number">1</span>] = a[len];</span><br><span class="line"><span class="built_in">AdjustHeap</span>(a,len<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">a[len] = tmp;</span><br><span class="line"><span class="built_in">PrintArry</span>(a,<span class="number">9</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//初次调整成大根堆 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = len/<span class="number">2</span>; i &gt;<span class="number">0</span>; --i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">AdjustHeap</span>(a,len,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//依次删除根节点 </span></span><br><span class="line"><span class="keyword">while</span>(len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DeleteRoot</span>(a,len);</span><br><span class="line">len--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">0</span>,<span class="number">12</span>,<span class="number">54</span>,<span class="number">65</span>,<span class="number">98</span>,<span class="number">48</span>,<span class="number">39</span>,<span class="number">73</span>,<span class="number">81</span>,<span class="number">27</span>&#125;;</span><br><span class="line"><span class="comment">//SelectSort(a,9);</span></span><br><span class="line"><span class="comment">//    SelectSortAdvance(a,9);</span></span><br><span class="line">    <span class="built_in">HeapSort</span>(a,<span class="number">9</span>); </span><br><span class="line"><span class="built_in">PrintArry</span>(a,<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>算法分析：<br>堆排序的时间复杂度为nlog2n.</p><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出图的BFS和DFS</title>
      <link href="/2024/06/12/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%9B%BE%E7%9A%84BFS%E5%92%8CDFS/"/>
      <url>/2024/06/12/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%9B%BE%E7%9A%84BFS%E5%92%8CDFS/</url>
      
        <content type="html"><![CDATA[<h1 id="深入浅出理解-图的-DFS-和-BFS"><a href="#深入浅出理解-图的-DFS-和-BFS" class="headerlink" title="深入浅出理解 图的 DFS 和 BFS"></a>深入浅出理解 图的 DFS 和 BFS</h1><hr><h2 id="一、邻接表法建立图"><a href="#一、邻接表法建立图" class="headerlink" title="一、邻接表法建立图"></a>一、邻接表法建立图</h2><p>创建图的方法有邻接矩阵和邻接表法。</p><blockquote><ul><li><font color = "#0x552266"> 邻接矩阵把边的关系包含在一个矩阵中，虽然很方便，但是，当图中的定点数远大于边数时，浪费了很大的空间。</li><li><font color = "#0x552266">邻接表把边与顶点的关系存在一个叫弧（边）的数据结构中，有几条边就创建几条弧。节省了内存空间，但也怎加了对各种结构体之间关系的理解难度。</li><li><font color = "#0x552266">其实图的DFS和BFS就算法上来看，是非常简单的，但是要很流利的写出图的这两种遍历的算法，要对结构体之间关系有较好的理解。</li></ul></blockquote><p>下面先来看数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span>DG,DN,UDG,UDN&#125;GraphyType; <span class="comment">//图的种类</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>  //弧结点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> adjVerxIndex;    <span class="comment">//该弧指向的顶点在图中顶点数组的下标</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>* <span class="title">nextArc</span>;</span>  <span class="comment">//该弧在邻接表中的下一条弧</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span>  //顶点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> data;   <span class="comment">//顶点数据</span></span><br><span class="line">ArcNode* firstArc;   <span class="comment">//该顶点相连的第一条弧</span></span><br><span class="line">&#125;VertexNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">graphy</span> //邻接表（图）</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">VertexNode vertex[MAXSIZE];</span><br><span class="line"><span class="type">int</span> verNum,arcNum;</span><br><span class="line">GraphyType type;<span class="comment">//图的种类，若要简单可以舍去这一项</span></span><br><span class="line">&#125;*AdjList;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再来看如何创建图：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Locate</span><span class="params">(AdjList adj , <span class="type">char</span> des)</span> <span class="comment">//通过顶点数据找到顶点下标</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; adj-&gt;verNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(des == adj-&gt;vertex[i].data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CreatAdjList</span><span class="params">(AdjList* adj)</span><span class="comment">//创建图</span></span><br><span class="line">&#123;</span><br><span class="line">*adj = (AdjList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(graphy));</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入顶点数：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;(*adj)-&gt;verNum;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入边数：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;(*adj)-&gt;arcNum;</span><br><span class="line">(*adj)-&gt;type = DN;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请依次输入顶点的值：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; (*adj)-&gt;verNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;(*adj)-&gt;vertex[i].data;</span><br><span class="line">(*adj)-&gt;vertex[i].firstArc = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; (*adj)-&gt;arcNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> start,end;</span><br><span class="line"><span class="type">int</span> ixS,ixE;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入第&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;条边的两个顶点值：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;start&gt;&gt;end;</span><br><span class="line">ixS = Locate(*adj,start);</span><br><span class="line">ixE = Locate(*adj,end);</span><br><span class="line">ArcNode* node = (ArcNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line">node-&gt;nextArc = (*adj)-&gt;vertex[ixS].firstArc;</span><br><span class="line">node-&gt;adjVerxIndex = ixE;</span><br><span class="line">(*adj)-&gt;vertex[ixS].firstArc = node;<span class="comment">//头插法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没什么难以理解的，就是把图结构体中的变量初始化，唯一要注意的是，在创建边的时候，采用头插还是尾插的方法对最后遍历结果有一定影响，实际上先遍历哪一个邻接点都没有关系，所以图的两种遍历结果其实都是不唯一的，只要某些关键点的前后顺序一致就行了。</p><hr><h2 id="二、图的深度优先遍历（DFS）"><a href="#二、图的深度优先遍历（DFS）" class="headerlink" title="二、图的深度优先遍历（DFS）"></a>二、图的深度优先遍历（DFS）</h2><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a><font color = "#0x6600ff" size = "4px"><em><strong>算法分析</strong></em></h3><p>图的深度优先遍历其实就是通常说的回溯，一般用递归实现，做法是依次对每个未访问的结点做DFS。</p><p>DFS：访问该顶点，然后<strong>在一个循环中分别对每一个邻接点做DFS</strong>,直到所有邻接点都已做完DFS返回，可见DFS使用了递归。</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Dfs</span><span class="params">(AdjList adj, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(flag[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;adj-&gt;vertex[i].data&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">flag[i] = <span class="literal">true</span>;</span><br><span class="line">ArcNode* p = adj-&gt;vertex[i].firstArc; </span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line">Dfs(adj,p-&gt;adjVerxIndex);</span><br><span class="line">p = p-&gt;nextArc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="三、图的广度优先遍历（BFS）"><a href="#三、图的广度优先遍历（BFS）" class="headerlink" title="三、图的广度优先遍历（BFS）"></a>三、图的广度优先遍历（BFS）</h2><h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a><font color = "#0x6600ff" size = "4px"><em><strong>算法分析</strong></em></h3><ol><li>图的广度优先遍历一般用队列来实现，和深度优先遍历一样，依次对图中每一个未访问的顶点做BFS.</li><li>BFS：访问一个节点之前，现将这个顶点入队，然后在访问，访问完毕之后，将他的<strong>所有邻接点入队</strong>。然后判断队列是否为空，若为空则表示访问完毕，退出循环，可见BFS未用递归。</li></ol><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Bfs</span><span class="params">(AdjList adj,<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">q.push(i);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!flag[q.front()])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;adj-&gt;vertex[q.front()].data&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">    flag[q.front()] = <span class="literal">true</span>;    </span><br><span class="line">&#125;</span><br><span class="line">ArcNode* p = adj-&gt;vertex[q.front()].firstArc;</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">q.push(p-&gt;adjVerxIndex);</span><br><span class="line">p = p-&gt;nextArc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h2 id="四、整体实现及测试结果"><a href="#四、整体实现及测试结果" class="headerlink" title="四、整体实现及测试结果"></a>四、整体实现及测试结果</h2><h3 id="1-画图分析："><a href="#1-画图分析：" class="headerlink" title="1. 画图分析："></a>1. 画图分析：</h3><p>12579</p><h3 id="2-整体代码："><a href="#2-整体代码：" class="headerlink" title="2. 整体代码："></a>2. 整体代码：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 20</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span>DG,DN,UDG,UDN&#125;GraphyType;</span><br><span class="line"><span class="type">bool</span> flag[MAXSIZE] = &#123;<span class="literal">false</span>&#125;; </span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> adjVerxIndex;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>* <span class="title">nextArc</span>;</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> data;</span><br><span class="line">ArcNode* firstArc;</span><br><span class="line">&#125;VertexNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">graphy</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">VertexNode vertex[MAXSIZE];</span><br><span class="line"><span class="type">int</span> verNum,arcNum;</span><br><span class="line">GraphyType type;</span><br><span class="line">&#125;*AdjList;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Dfs</span><span class="params">(AdjList adj, <span class="type">int</span> i)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Bfs</span><span class="params">(AdjList adj,<span class="type">int</span> i)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Locate</span><span class="params">(AdjList adj , <span class="type">char</span> des)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; adj-&gt;verNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(des == adj-&gt;vertex[i].data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CreatAdjList</span><span class="params">(AdjList* adj)</span></span><br><span class="line">&#123;</span><br><span class="line">*adj = (AdjList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(graphy));</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入顶点数：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;(*adj)-&gt;verNum;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入边数：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;(*adj)-&gt;arcNum;</span><br><span class="line">(*adj)-&gt;type = DN;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请依次输入顶点的值：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; (*adj)-&gt;verNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;(*adj)-&gt;vertex[i].data;</span><br><span class="line">(*adj)-&gt;vertex[i].firstArc = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; (*adj)-&gt;arcNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> start,end;</span><br><span class="line"><span class="type">int</span> ixS,ixE;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入第&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;条边的两个顶点值：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;start&gt;&gt;end;</span><br><span class="line">ixS = Locate(*adj,start);</span><br><span class="line">ixE = Locate(*adj,end);</span><br><span class="line">ArcNode* node = (ArcNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line">node-&gt;nextArc = (*adj)-&gt;vertex[ixS].firstArc;</span><br><span class="line">node-&gt;adjVerxIndex = ixE;</span><br><span class="line">(*adj)-&gt;vertex[ixS].firstArc = node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(AdjList adj)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; adj-&gt;verNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(flag[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;DFS:&quot;</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    Dfs(adj,i);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(flag,<span class="number">0</span>,MAXSIZE);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; adj-&gt;verNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(flag[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">&quot;BFS:&quot;</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    Bfs(adj,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Dfs</span><span class="params">(AdjList adj, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(flag[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;adj-&gt;vertex[i].data&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">flag[i] = <span class="literal">true</span>;</span><br><span class="line">ArcNode* p = adj-&gt;vertex[i].firstArc; </span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line">Dfs(adj,p-&gt;adjVerxIndex);</span><br><span class="line">p = p-&gt;nextArc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Bfs</span><span class="params">(AdjList adj,<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">q.push(i);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!flag[q.front()])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;adj-&gt;vertex[q.front()].data&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">    flag[q.front()] = <span class="literal">true</span>;    </span><br><span class="line">&#125;</span><br><span class="line">ArcNode* p = adj-&gt;vertex[q.front()].firstArc;</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">q.push(p-&gt;adjVerxIndex);</span><br><span class="line">p = p-&gt;nextArc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">AdjList adj;</span><br><span class="line">    CreatAdjList(&amp;adj);</span><br><span class="line">    Print(adj);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="3-结果："><a href="#3-结果：" class="headerlink" title="3.结果："></a>3.结果：</h3><p>28255</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
